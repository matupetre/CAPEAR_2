#include "LPC17xx.h"
#include "capear_definiciones.h"
#include "uip.h"
//#include "uip.c"

#define ICMPBUF ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define UIP_ICMPH_LEN 8		//tamaño del encabezado ICMP

u16_t
uip_ICMPchksum(u16_t tamano_total_datagrama)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN+UIP_IPH_LEN], tamano_total_datagrama - UIP_IPH_LEN);
  /*expli: 	el 1er arg es 0 no se xq ni me importa por el momento
   * 		el 2do arg es el offset donde empieza a tomarse el cacho a checksumear.
   * 			en este caso uip_buf es un frame completo de ethernet. Como a nosotros
   * 			solo nos interesa el ICMP, primero comenzamos por descartar la parte de
   * 			ethernet y nos vamos a UIP_LLH_LEN que es donde empieza el datagrama IP,
   * 			Pero aqui necesitamos solo el ICMP, por lo que descartamos el ecabezado
   * 			del datagrama IP (20 bytes==UIP_IPH_LEN) y recien ahora llegamos a donde
   * 			comienza el paquete ICMP. Este es el offset, Mision cumplida!
   * 		el 3er arg es el tamaño total del cacho a checksumear, al mismo lo obtenemos
   * 			tomando el tamaño total del datagrama (dije datagrama, o sea el paquete
   * 			IP, esto no cuenta la parte de Ethernet) y restándole el encabezado del
   * 			mismo. Con esto obtenemos el tamaño de los DATOS del datagrama que no es
   * 			otra cosa que el paquete ICMP total encapsulado en el mismo.
   */

  DEBUG_PRINTF("uip_ICMPchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
}

void
pong(char* destipaddr)

	{
	//PROPOSITO DE LA FUNCION: emitir un  PING!!!

	//pero hasta que se descule lo anterior...
	//se togglea el puerto 0 (LED2 por ahora) para indicar que
	//se recibio una respuesta a nuestro PING enviado.

	//NOTA POST: Ya no es nesario!! el ping funciona OKAPA
	/*
	PRT0_PIO->FIOMASK = 0;
	PRT0_PIO->FIOPIN ^= (1 << PRT0_pin);
	*/

	// *uip_buf[UIP_LLH_LEN+UIP_IPH_LEN+8]=(int) 66;
	u8_t tamano_total_datagrama=UIP_IPH_LEN+UIP_ICMPH_LEN;

	//Encabezado del datagrama IP
	ICMPBUF->vhl=0x45;
	ICMPBUF->tos=0x00;
	ICMPBUF->len[0]=0x00;
	ICMPBUF->len[1]=tamano_total_datagrama;
	ICMPBUF->ipid[0]=0xca;
	ICMPBUF->ipid[1]=0x9e;
	ICMPBUF->ipoffset[0]=0x40;
	ICMPBUF->ipoffset[1]=0x00;
	ICMPBUF->ttl=128;
	ICMPBUF->proto=1;	//indica que el datagrama contiene un ICMP
	ICMPBUF->srcipaddr[0]=HTONS((SRV_IP_1 << 8) | SRV_IP_2);
	ICMPBUF->srcipaddr[1]=HTONS((SRV_IP_3 << 8) | SRV_IP_4);
	ICMPBUF->destipaddr[0]=HTONS((IP1 << 8) | IP2);
	ICMPBUF->destipaddr[1]=HTONS((IP3 << 8) | IP4);
	//el checksum lo calculamos al final, una vez que esta armado el resto del encabezado
	ICMPBUF->ipchksum=0;	//es nesario fijarlo a 0 previo a invocar el siguiente
	ICMPBUF->ipchksum= ~(uip_ipchksum());

	//Encabezado del ICMP
	ICMPBUF->type=8;			//indica PING ECHO REQUEST (la respuesta contiene un cero)
	ICMPBUF->icode=0;
	ICMPBUF->id=0x9eca;			//ca9e = CAPE(AR) ;)
	ICMPBUF->seqno=1;
	//el checksum lo calculamos al final, una vez que esta armado el resto del encabezado
	ICMPBUF->icmpchksum=0;
	ICMPBUF->icmpchksum= ~(uip_ICMPchksum((u16_t) tamano_total_datagrama));

	//la siguiente variable es global!
	uip_len=tamano_total_datagrama;


	};
